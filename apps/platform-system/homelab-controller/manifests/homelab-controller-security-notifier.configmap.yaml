---
apiVersion: v1
kind: ConfigMap
metadata:
  name: homelab-controller-security-notifier
  namespace: platform-system
  labels:
    app.kubernetes.io/name: homelab-controller
    app.kubernetes.io/part-of: homelab-controller
data:
  security_notifier.py: |-
    """
    Security Notifier Module for homelab-controller.

    Collects security alerts and sends a daily digest to Telegram:
    - Falco runtime security alerts (via native HTTP output)
    """
    import json
    import logging
    import os
    import threading
    import time
    from datetime import datetime
    from pathlib import Path

    import urllib.request

    TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN", "")
    TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID", "")
    DIGEST_TIME = os.environ.get("DIGEST_TIME", "08:00")  # 24h format, local time
    ALERTS_FILE = os.environ.get("ALERTS_FILE", "/data/alerts/pending.json")
    MAX_ALERTS_PER_TYPE = int(os.environ.get("MAX_ALERTS_PER_TYPE", "1000"))  # Prevent unbounded growth

    logger = logging.getLogger("security_notifier")

    # Lock for file operations
    _file_lock = threading.Lock()

    def _escape_markdown(text: str) -> str:
        """Escape special characters for Telegram Markdown (legacy mode)."""
        escape_chars = r"_*`["
        return re.sub(f"([{re.escape(escape_chars)}])", r"\\\1", str(text))

    def _load_alerts() -> dict:
        """Load alerts from persistent storage."""
        default = {"falco": [], "last_digest_date": ""}
        try:
            path = Path(ALERTS_FILE)
            if path.exists():
                with open(path, "r") as f:
                    data = json.load(f)
                    # Keep only known keys and ensure defaults exist.
                    return {key: data.get(key, default[key]) for key in default}
        except Exception as exc:
            logger.warning("Failed to load alerts file: %s", exc)
        return default

    def _save_alerts(alerts: dict) -> None:
        """Save alerts to persistent storage (atomic write)."""
        try:
            path = Path(ALERTS_FILE)
            path.parent.mkdir(parents=True, exist_ok=True)
            tmp_path = path.with_suffix(".tmp")
            with open(tmp_path, "w") as f:
                json.dump(alerts, f)
            tmp_path.rename(path)  # Atomic on POSIX
        except Exception as exc:
            logger.exception("Failed to save alerts file: %s", exc)

    def _add_alert(alert_type: str, alert_data: dict) -> None:
        """Add an alert to persistent storage."""
        with _file_lock:
            alerts = _load_alerts()
            if alert_type not in alerts:
                alerts[alert_type] = []
            alerts[alert_type].append(alert_data)
            # Prevent unbounded growth - keep only recent alerts
            if len(alerts[alert_type]) > MAX_ALERTS_PER_TYPE:
                alerts[alert_type] = alerts[alert_type][-MAX_ALERTS_PER_TYPE:]
            _save_alerts(alerts)

    def _send_telegram(message: str) -> bool:
        """Send a message to Telegram."""
        if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
            logger.warning("Telegram credentials not configured, skipping notification")
            return False

        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {
            "chat_id": TELEGRAM_CHAT_ID,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True,
        }

        try:
            data = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(
                url,
                data=data,
                headers={"Content-Type": "application/json"},
                method="POST",
            )
            with urllib.request.urlopen(req, timeout=10) as resp:
                if resp.status == 200:
                    logger.info("Telegram notification sent successfully")
                    return True
                logger.error("Telegram API returned status %s", resp.status)
                return False
        except Exception as exc:
            logger.exception("Failed to send Telegram notification: %s", exc)
            return False

    def _format_digest(alerts: dict) -> str | None:
        """Format the daily security digest."""
        falco_alerts = alerts.get("falco", [])

        if not falco_alerts:
            return None

        today = datetime.now().strftime("%b %d, %Y")
        lines = [f"ðŸ“Š *Daily Security Digest* ({today})\n"]

        # Falco section
        lines.append("ðŸ›¡ï¸ *FALCO - Runtime Security*")
        lines.append("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

        # Aggregate by rule
        rules: dict[str, dict] = {}
        priority_counts = {"CRITICAL": 0, "ERROR": 0, "WARNING": 0, "NOTICE": 0, "INFO": 0}
        for alert in falco_alerts:
            rule = alert.get("rule", "unknown")
            priority = (alert.get("priority") or "INFO").upper()
            if priority in priority_counts:
                priority_counts[priority] += 1
            if rule not in rules:
                rules[rule] = {"count": 0, "priority": priority}
            rules[rule]["count"] += 1

        critical = priority_counts["CRITICAL"] + priority_counts["ERROR"]
        warning = priority_counts["WARNING"]
        lines.append(f"Total: {len(falco_alerts)} alerts | ðŸ”´ {critical} Critical | ðŸŸ  {warning} Warning\n")

        # Sort by count
        sorted_rules = sorted(rules.items(), key=lambda x: x[1]["count"], reverse=True)[:5]
        if sorted_rules:
            lines.append("Rules triggered:")
            for rule, data in sorted_rules:
                lines.append(f"â€¢ {_escape_markdown(rule)}: {data['count']}")

        return "\n".join(lines)

    def send_daily_digest() -> bool:
        """Send the daily digest and clear alerts (atomic operation)."""
        with _file_lock:
            alerts = _load_alerts()
            digest = _format_digest(alerts)

            if not digest:
                logger.info("No alerts to report in daily digest")
                # Still update last_digest_date to prevent retries
                alerts["last_digest_date"] = datetime.now().strftime("%Y-%m-%d")
                _save_alerts(alerts)
                return True

            # Split into chunks if too long (truncate at newline to avoid breaking markdown)
            if len(digest) <= 4000:
                success = _send_telegram(digest)
            else:
                truncated = digest[:4000].rsplit("\n", 1)[0]
                success = _send_telegram(truncated + "\n...(truncated)")

            if success:
                # Atomic clear with date update - inside the same lock
                _save_alerts({
                    "falco": [],
                    "last_digest_date": datetime.now().strftime("%Y-%m-%d"),
                })
                logger.info("Daily security digest sent successfully")

            return success

    def handle_falco_webhook(body: dict) -> dict:
        """Handle incoming Falco native HTTP output event."""
        rule = body.get("rule", "unknown")
        priority = (body.get("priority") or "unknown").upper()
        fields = body.get("output_fields") or {}
        namespace = fields.get("k8s.ns.name", "N/A")
        container = fields.get("container.name") or fields.get("k8s.pod.name", "N/A")

        logger.info("Received Falco alert: rule=%s priority=%s", rule, priority)

        _add_alert("falco", {
            "rule": rule,
            "priority": priority,
            "namespace": namespace,
            "container": container,
            "timestamp": time.time(),
        })

        return {"status": "queued"}

    def start_background_tasks(kube_get, kube_logs, ctx):
        """Start background threads for periodic tasks."""

        def digest_scheduler():
            """Check if it's time to send the daily digest."""
            while True:
                time.sleep(60)  # Check every minute
                try:
                    now = datetime.now()
                    current_date = now.strftime("%Y-%m-%d")

                    # Parse target time
                    try:
                        target_hour, target_minute = map(int, DIGEST_TIME.split(":"))
                    except ValueError:
                        target_hour, target_minute = 8, 0

                    # Window-based matching: within 5 minutes after target time
                    if now.hour == target_hour and 0 <= now.minute - target_minute < 5:
                        # Check if already sent today (read from persisted state)
                        with _file_lock:
                            alerts = _load_alerts()
                            last_date = alerts.get("last_digest_date", "")

                        if last_date != current_date:
                            logger.info("Sending daily security digest...")
                            send_daily_digest()

                except Exception as exc:
                    logger.exception("Digest scheduler error: %s", exc)

        threading.Thread(target=digest_scheduler, daemon=True, name="digest-scheduler").start()
        logger.info("Started background tasks (digest at %s)", DIGEST_TIME)
