---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hajimari-config-sync-scripts
  namespace: edge-services
data:
  generator.py: |-
    import copy
    import logging
    import os
    import sys
    import time
    import urllib.parse
    import urllib.request
    from dataclasses import dataclass
    from pathlib import Path
    from typing import Iterable, Optional, Sequence, TypedDict

    try:
        import yaml
    except ImportError:  # pragma: no cover - handled in container entrypoint
        sys.exit("PyYAML is required")

    KUBE_TIMEOUT = float(os.environ.get("KUBE_TIMEOUT", "5"))
    KUBE_RETRIES = int(os.environ.get("KUBE_RETRIES", "2"))
    KUBE_BACKOFF = float(os.environ.get("KUBE_BACKOFF", "0.5"))

    DEFAULT_SELECTOR = os.environ.get("DISCOVERY_SELECTOR", "")
    DEFAULT_ICON = "mdi:web"

    class ClusterContext(TypedDict):
        host: str
        port: str
        token: str
        ca_path: Path

    def setup_logging():
        level = os.environ.get("LOG_LEVEL", "INFO").upper()
        logging.basicConfig(
            level=getattr(logging, level, logging.INFO),
            format="%(asctime)s %(levelname)s %(name)s %(message)s",
        )
        return logging.getLogger("generator")

    def cluster_context() -> ClusterContext:
        host = os.environ.get("KUBERNETES_SERVICE_HOST")
        port = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
        if not host:
            raise SystemExit("missing KUBERNETES_SERVICE_HOST")
        token_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/token")
        ca_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
        token = token_path.read_text(encoding="utf-8").strip()
        return {"host": host, "port": port, "token": token, "ca_path": ca_path}

    def kube_get(path: str, ctx: ClusterContext, *, timeout: float | None = None, retries: int | None = None, backoff: float | None = None):
        import ssl
        from urllib.error import HTTPError, URLError

        retries = KUBE_RETRIES if retries is None else retries
        backoff = KUBE_BACKOFF if backoff is None else backoff

        url = f"https://{ctx['host']}:{ctx['port']}{path}"
        req = urllib.request.Request(
            url,
            headers={
                "Authorization": f"Bearer {ctx['token']}",
                "Accept": "application/json",
            },
        )
        ssl_ctx = ssl.create_default_context(cafile=str(ctx["ca_path"]))
        ssl_ctx.check_hostname = False
        attempt = 0
        while True:
            attempt += 1
            try:
                with urllib.request.urlopen(req, context=ssl_ctx, timeout=timeout or KUBE_TIMEOUT) as resp:
                    return yaml.safe_load(resp.read())
            except (HTTPError, URLError) as exc:
                if attempt > retries:
                    raise RuntimeError(f"failed to GET {path}: {exc}") from exc
                time.sleep(backoff * attempt)

    def discover(selector: str, logger, ctx: ClusterContext):
        selector = selector or "hajimari.edgard.org/enabled=true,external-dns.edgard.org/scope=external"
        DEFAULT_ICON = "mdi:web"

        @dataclass
        class Entry:
            host: str
            namespace: str
            routename: str
            icon: Optional[str]

        def routes_to_entries(items: Sequence[dict]):
            entries = []
            for item in items or []:
                meta = item.get("metadata", {}) or {}
                labels = meta.get("labels", {}) or {}
                if labels.get("homelab.edgard.org/managed") == "hajimari":
                    continue
                if labels.get("hajimari.edgard.org/enabled") != "true":
                    continue
                ns = meta.get("namespace")
                name = meta.get("name")
                icon = labels.get("hajimari.edgard.org/icon")
                for host in item.get("spec", {}).get("hostnames", []) or []:
                    entries.append(Entry(host=host, namespace=ns, routename=name, icon=icon))
            return entries

        def list_routes(ctx: ClusterContext, selector: str):
            encoded = urllib.parse.quote(selector, safe="=,")
            data = kube_get(
                f"/apis/gateway.networking.k8s.io/v1/httproutes?labelSelector={encoded}",
                ctx,
            )
            return data.get("items", []) if data else []

        def build_config(entries: Iterable[Entry], base: dict) -> dict:
            groups = {}
            seen_hosts = set()
            seen_names = set()
            for entry in entries:
                key = entry.host.lower()
                if key in seen_hosts:
                    continue
                name = entry.host.split(".")[0].replace("-", " ").title()
                if name in seen_names:
                    continue
                seen_hosts.add(key)
                seen_names.add(name)
                grp = groups.setdefault(entry.namespace, {"apps": []})
                grp["apps"].append(
                    {
                        "name": name,
                        "url": f"https://{entry.host}",
                        "icon": f"mdi:{entry.icon}" if entry.icon else DEFAULT_ICON,
                        "info": f"{entry.namespace}/{entry.routename}",
                        "targetBlank": False,
                    }
                )

            for grp in groups.values():
                grp["apps"].sort(key=lambda x: x["name"].lower())

            custom_apps = [
                {"group": ns.replace("-", " ").title(), "apps": grp["apps"]}
                for ns, grp in sorted(groups.items(), key=lambda x: x[0])
            ]

            base["customApps"] = custom_apps
            return base

        routes = list_routes(ctx, selector)
        entries = routes_to_entries(routes)

        cfg = build_config(entries, {})
        custom_apps = cfg.get("customApps", [])

        discovered_apps = custom_apps
        total = sum(len(g.get("apps", [])) for g in discovered_apps)
        stats = {
            "appCount": total,
            "endpointCount": total,
            "discoveredCount": total,
        }
        return custom_apps, stats

    def patch_config(config: dict, data: list):
        config['customApps'] = data

    def render_config(base_config: dict, selector: str, logger, *, ctx: ClusterContext | None = None, trace: str | None = None):
        if not base_config:
            raise SystemExit("base config is required")
        if ctx is None:
            ctx = cluster_context()

        data_list, stats = discover(selector, logger, ctx)

        cfg = copy.deepcopy(base_config)
        patch_config(cfg, data_list)

        logger.debug(
            "rendered config trace=%s endpoints=%s discovered=%s selector=%s",
            trace or "-",
            stats.get("endpointCount"),
            stats.get("discoveredCount"),
            selector,
        )
        return cfg, stats

    def main():  # pragma: no cover - manual execution helper
        logger = setup_logging()
        ctx = cluster_context()

        base_path = Path(os.environ.get("CONFIG_TEMPLATE", "/scripts/base.yaml.j2"))
        out_path = Path(os.environ.get("CONFIG_OUT", "/config/config.yaml"))

        try:
            base_config = yaml.safe_load(base_path.read_text(encoding="utf-8"))
        except Exception:
            base_config = {}

        cfg, stats = render_config(base_config=base_config, selector=DEFAULT_SELECTOR, logger=logger, ctx=ctx, trace="standalone")

        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(yaml.safe_dump(cfg, sort_keys=False), encoding="utf-8")
        logger.debug(
            "generated config apps=%s endpoints=%s discovered=%s selector=%s path=%s",
            stats.get("appCount"),
            stats.get("endpointCount"),
            stats.get("discoveredCount"),
            DEFAULT_SELECTOR,
            str(out_path),
        )

    if __name__ == "__main__":
        main()
  webhook.py: |-
    import hashlib
    import json
    import logging
    import os
    from datetime import datetime, timezone
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from pathlib import Path

    import yaml

    import generator

    LOG_LEVEL = os.environ.get("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, LOG_LEVEL, logging.INFO),
        format="%(asctime)s %(levelname)s %(name)s %(message)s",
    )

    DEFAULT_SELECTOR = os.environ.get("DISCOVERY_SELECTOR", generator.DEFAULT_SELECTOR)
    DEFAULT_RESYNC = int(os.environ.get("RESYNC_SECONDS", "120"))
    DEFAULT_OUTPUT_KEY = os.environ.get("OUTPUT_KEY", "config.yaml")
    SERVER_PORT = int(os.environ.get("WEBHOOK_PORT", "8080"))

    def get_current_namespace():
        try:
            return Path("/var/run/secrets/kubernetes.io/serviceaccount/namespace").read_text().strip()
        except Exception:
            return "default"

    def build_response(parent: dict, logger):
        metadata = parent.get("metadata") or {}
        spec = parent.get("spec") or {}
        parent_status = parent.get("status") or {}

        # Derive managed resource from Kind (e.g. DexConfig -> dex)
        kind = parent.get("kind", "")
        managed_resource = kind.replace("Config", "").lower() or "unknown"
        default_output_cm = f"{managed_resource}-config-generated"

        namespace = metadata.get("namespace") or get_current_namespace()
        output_name = spec.get("outputConfigMap") or default_output_cm
        output_key = spec.get("outputKey") or DEFAULT_OUTPUT_KEY
        selector = spec.get("discoverySelector") or DEFAULT_SELECTOR
        resync = int(spec.get("resyncSeconds") or DEFAULT_RESYNC)

        base_config = spec.get("base", {})

        # Use generator.cluster_context() directly if available, or generic one
        ctx = generator.cluster_context()

        config, stats = generator.render_config(
            base_config=base_config,
            selector=selector,
            logger=logger,
            ctx=ctx,
            trace=f"{namespace}/{metadata.get('name', '')}",
        )

        cfg_yaml = yaml.safe_dump(config, sort_keys=False)
        cfg_hash = hashlib.sha256(cfg_yaml.encode("utf-8")).hexdigest()

        endpoints = stats.get("endpointCount", 0)
        discovered = stats.get("discoveredCount", endpoints)
        app_count = stats.get("appCount", endpoints)

        prev_hash = parent_status.get("configHash")

        if prev_hash == cfg_hash:
            status = parent_status
        else:
            now = datetime.now(timezone.utc).isoformat()
            status = {
                "lastSync": now,
                "appCount": app_count,
                "endpointCount": endpoints,
                "discovered": discovered,
                "configHash": cfg_hash,
                "conditions": [
                    {
                        "type": "Ready",
                        "status": "True",
                        "reason": "SyncSuccessful",
                        "message": f"Rendered {endpoints} endpoints ({discovered} discovered)",
                        "lastTransitionTime": now,
                    }
                ],
            }

        logger.info(
            "sync successful parent=%s/%s cm=%s selector=%s endpoints=%s discovered=%s",
            namespace,
            metadata.get("name"),
            output_name,
            selector,
            endpoints,
            discovered,
        )

        return {
            "children": [
                {
                    "apiVersion": "v1",
                    "kind": "ConfigMap",
                    "metadata": {
                        "name": output_name,
                        "namespace": namespace,
                        "labels": {
                            "app.kubernetes.io/name": managed_resource,
                            "app.kubernetes.io/part-of": managed_resource,
                        "homelab.edgard.org/managed": managed_resource,
                        },
                    },
                    "data": {output_key: cfg_yaml},
                }
            ],
            "status": status,
            "resyncAfterSeconds": resync,
        }

    class Handler(BaseHTTPRequestHandler):
        def do_POST(self):  # noqa: N802 - metacontroller expects POST
            if self.path != "/sync":
                self.send_error(404, "not found")
                return

            length = int(self.headers.get("Content-Length", "0"))
            raw_body = self.rfile.read(length) if length else b"{}"
            try:
                body = json.loads(raw_body or b"{}")
            except json.JSONDecodeError as exc:
                self._write_json(400, {"error": f"invalid json: {exc}"})
                return

            parent = body.get("parent") or {}
            spec = parent.get("spec") or {}
            resync = int(spec.get("resyncSeconds") or DEFAULT_RESYNC)
            logger = logging.getLogger("webhook")

            try:
                response = build_response(parent, logger)
                self._write_json(200, response)
            except Exception as exc:  # pragma: no cover - surfaced via status
                now = datetime.now(timezone.utc).isoformat()
                logging.exception("sync error")
                # Use DEFAULT_RESYNC as fallback if parsing failed
                resync = DEFAULT_RESYNC
                self._write_json(
                    200,
                    {
                        "status": {
                            "lastSync": now,
                            "appCount": 0,
                            "endpointCount": 0,
                            "discovered": 0,
                            "configHash": None,
                            "conditions": [
                                {
                                    "type": "Ready",
                                    "status": "False",
                                    "reason": "SyncError",
                                    "message": str(exc),
                                    "lastTransitionTime": now,
                                }
                            ],
                        },
                        "resyncAfterSeconds": resync,
                    },
                )

        def log_message(self, fmt, *args):  # pragma: no cover - quiet logs
            return

        def _write_json(self, code, payload):
            data = json.dumps(payload).encode("utf-8")
            self.send_response(code)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(data)))
            self.end_headers()
            self.wfile.write(data)

        def do_GET(self):
            if self.path in ("/healthz", "/livez", "/readyz"):
                self._write_json(200, {"status": "ok"})
            else:
                self.send_error(404, "not found")

    if __name__ == "__main__":
        server = HTTPServer(("", SERVER_PORT), Handler)
        logging.getLogger("webhook").info(
            "starting metacontroller webhook on :%s",
            SERVER_PORT,
        )
        server.serve_forever()
