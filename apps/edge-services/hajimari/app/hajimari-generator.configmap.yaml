---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hajimari-generator
  namespace: edge-services
data:
  base.yaml: |-
    title: Homelab
    defaultEnable: true
    showRecent: true
    showAppGroups: true
    showGreeting: false
    showSearch: false
    showBookmarks: false
    showBookmarkGroups: false
    showAppUrls: false
    showAppInfo: false
    showAppStatus: false
    lightTheme: paper
    darkTheme: chalk
  generator.py: |-
    import json
    import os
    import ssl
    import sys
    import urllib.error
    import urllib.parse
    import urllib.request
    from dataclasses import dataclass
    from pathlib import Path

    try:
        import yaml
    except ImportError:  # pragma: no cover - handled in init container shell
        sys.exit("PyYAML is required")

    ROUTE_SELECTOR = "hajimari.edgard.org/enabled=true,external-dns.edgard.org/scope=external"
    DEFAULT_ICON = "mdi:web"


    @dataclass
    class Entry:
        host: str
        namespace: str
        routename: str
        icon: str | None


    def display_name(hostname: str) -> str:
        clean = hostname.replace(".edgard.org", "")
        if clean in ("www", "edgard.org"):
            return "Website"
        left = clean.split(".")[0]
        return left.replace("-", " ").title()


    def display_icon(icon_override: str | None) -> str:
        return f"mdi:{icon_override}" if icon_override else DEFAULT_ICON


    def fetch_json(host, port, token, ctx, path, ignore_404=True):
        url = f"https://{host}:{port}{path}"
        req = urllib.request.Request(
            url,
            headers={
                "Authorization": f"Bearer {token}",
                "Accept": "application/json",
            },
        )
        try:
            with urllib.request.urlopen(req, context=ctx) as resp:
                return json.loads(resp.read())
        except urllib.error.HTTPError as err:
            if ignore_404 and err.code == 404:
                return None
            raise


    def load_routes(host, port, token, ctx):
        selector = urllib.parse.quote(ROUTE_SELECTOR, safe="=,")
        data = fetch_json(
            host,
            port,
            token,
            ctx,
            f"/apis/gateway.networking.k8s.io/v1/httproutes?labelSelector={selector}",
        )
        if not data:
            return []

        entries = []
        for item in data.get("items", []):
            meta = item.get("metadata", {}) or {}
            labels = meta.get("labels", {}) or {}
            if labels.get("hajimari.edgard.org/enabled") != "true":
                continue
            ns = meta.get("namespace")
            name = meta.get("name")
            icon = labels.get("hajimari.edgard.org/icon")
            for host in item.get("spec", {}).get("hostnames", []) or []:
                entries.append(Entry(host=host, namespace=ns, routename=name, icon=icon))
        return entries


    def build_config(entries, base):
        groups = {}
        seen_hosts = set()
        seen_names = set()
        for entry in entries:
            key = entry.host.lower()
            if key in seen_hosts:
                continue
            name = display_name(entry.host)
            if name in seen_names:
                continue
            seen_hosts.add(key)
            seen_names.add(name)
            grp = groups.setdefault(entry.namespace, {"apps": []})
            grp["apps"].append(
                {
                    "name": name,
                    "url": f"https://{entry.host}",
                    "icon": display_icon(entry.icon),
                    "info": f"{entry.namespace}/{entry.routename}",
                    "targetBlank": False,
                }
            )

        for grp in groups.values():
            grp["apps"].sort(key=lambda x: x["name"].lower())

        custom_apps = [
            {"group": ns.replace("-", " ").title(), "apps": grp["apps"]}
            for ns, grp in sorted(groups.items(), key=lambda x: x[0])
        ]

        base["customApps"] = custom_apps
        return base


    def main():
        host = os.environ.get("KUBERNETES_SERVICE_HOST")
        port = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
        out_path = Path(os.environ.get("CONFIG_OUT", "/config/config.yaml"))
        base_path = Path(os.environ.get("CONFIG_TEMPLATE", "/generator/base.yaml"))
        token_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/token")
        ca_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

        if not host:
            sys.exit("missing KUBERNETES_SERVICE_HOST")

        token = token_path.read_text(encoding="utf-8").strip()

        ctx = ssl.create_default_context(cafile=ca_path)
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

        base = yaml.safe_load(base_path.read_text(encoding="utf-8")) or {}
        entries = load_routes(host, port, token, ctx)
        final_cfg = build_config(entries, base)

        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(yaml.safe_dump(final_cfg, sort_keys=False), encoding="utf-8")


    if __name__ == "__main__":
        main()
