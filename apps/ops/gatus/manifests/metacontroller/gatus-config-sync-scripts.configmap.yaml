---
apiVersion: v1
kind: ConfigMap
metadata:
  name: gatus-config-sync-scripts
  namespace: ops
data:
  generator.py: |-
    import copy
    import logging
    import os
    import sys
    import time
    import urllib.parse
    import urllib.request
    from dataclasses import dataclass
    from pathlib import Path
    from typing import Dict, Iterable, List, Optional, Sequence, Tuple, TypedDict

    try:
        import yaml
    except ImportError:
        sys.exit("PyYAML is required")

    KUBE_TIMEOUT = float(os.environ.get("KUBE_TIMEOUT", "5"))
    KUBE_RETRIES = int(os.environ.get("KUBE_RETRIES", "2"))
    KUBE_BACKOFF = float(os.environ.get("KUBE_BACKOFF", "0.5"))

    DEFAULT_SELECTOR = os.environ.get("DISCOVERY_SELECTOR", "")

    class ClusterContext(TypedDict):
        host: str
        port: str
        token: str
        ca_path: Path

    def setup_logging():
        level = os.environ.get("LOG_LEVEL", "INFO").upper()
        logging.basicConfig(
            level=getattr(logging, level, logging.INFO),
            format="%(asctime)s %(levelname)s %(name)s %(message)s",
        )
        return logging.getLogger("generator")

    def cluster_context() -> ClusterContext:
        host = os.environ.get("KUBERNETES_SERVICE_HOST")
        port = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
        if not host:
            raise SystemExit("missing KUBERNETES_SERVICE_HOST")
        token_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/token")
        ca_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
        token = token_path.read_text(encoding="utf-8").strip()
        return {"host": host, "port": port, "token": token, "ca_path": ca_path}

    def kube_get(path: str, ctx: ClusterContext, *, timeout: float | None = None, retries: int | None = None, backoff: float | None = None):
        import ssl
        from urllib.error import HTTPError, URLError

        retries = KUBE_RETRIES if retries is None else retries
        backoff = KUBE_BACKOFF if backoff is None else backoff

        url = f"https://{ctx['host']}:{ctx['port']}{path}"
        req = urllib.request.Request(
            url,
            headers={
                "Authorization": f"Bearer {ctx['token']}",
                "Accept": "application/json",
            },
        )
        ssl_ctx = ssl.create_default_context(cafile=str(ctx["ca_path"]))
        ssl_ctx.check_hostname = False
        attempt = 0
        while True:
            attempt += 1
            try:
                with urllib.request.urlopen(req, context=ssl_ctx, timeout=timeout or KUBE_TIMEOUT) as resp:
                    return yaml.safe_load(resp.read())
            except (HTTPError, URLError) as exc:
                if attempt > retries:
                    raise RuntimeError(f"failed to GET {path}: {exc}") from exc
                time.sleep(backoff * attempt)

    def discover(selector: str, logger, ctx: ClusterContext):
        selector = selector or "gatus.edgard.org/enabled=true"

        static_endpoints = [
            {
                "name": "dns-edgard-cloudflare",
                "group": "01-dns",
                "url": "1.1.1.1",
                "dns": {"query-name": "edgard.org", "query-type": "A"},
                "labels": {"namespace": "network", "scope": "external"},
                "interval": "1m",
                "conditions": ["[DNS_RCODE] == NOERROR"],
            },
            {
                "name": "dns-edgard-google",
                "group": "01-dns",
                "url": "8.8.8.8",
                "dns": {"query-name": "edgard.org", "query-type": "A"},
                "labels": {"namespace": "network", "scope": "external"},
                "interval": "1m",
                "conditions": ["[DNS_RCODE] == NOERROR"],
            },
            {
                "name": "ping-google",
                "group": "02-connectivity",
                "url": "icmp://www.google.com",
                "labels": {"namespace": "network", "scope": "external"},
                "interval": "1m",
                "conditions": ["[CONNECTED] == true"],
            },
            {
                "name": "ping-microsoft",
                "group": "02-connectivity",
                "url": "icmp://www.microsoft.com",
                "labels": {"namespace": "network", "scope": "external"},
                "interval": "1m",
                "conditions": ["[CONNECTED] == true"],
            },
            {
                "name": "ping-amazon",
                "group": "02-connectivity",
                "url": "icmp://www.amazon.com",
                "labels": {"namespace": "network", "scope": "external"},
                "interval": "1m",
                "conditions": ["[CONNECTED] == true"],
            },
            {
                "name": "envoy-gateway-external",
                "group": "03-gateway",
                "url": "tcp://envoy-gateway-external.platform-system.svc.cluster.local:443",
                "labels": {"namespace": "platform-system", "scope": "internal"},
                "interval": "30s",
                "conditions": ["[CONNECTED] == true"],
            },
            {
                "name": "envoy-gateway-internal",
                "group": "03-gateway",
                "url": "tcp://envoy-gateway-internal.platform-system.svc.cluster.local:443",
                "labels": {"namespace": "platform-system", "scope": "internal"},
                "interval": "30s",
                "conditions": ["[CONNECTED] == true"],
            },
            {
                "name": "envoy-gateway-external-https",
                "group": "03-gateway",
                "url": "https://id.edgard.org/",
                "labels": {"namespace": "platform-system", "scope": "external"},
                "interval": "1m",
                "conditions": ["[STATUS] >= 200", "[STATUS] < 400", "[CERTIFICATE_EXPIRATION] > 168h"],
            },
            {
                "name": "envoy-gateway-internal-https",
                "group": "03-gateway",
                "url": "https://id.edgard.org/",
                "labels": {"namespace": "platform-system", "scope": "internal"},
                "interval": "1m",
                "conditions": ["[STATUS] >= 200", "[STATUS] < 400", "[CERTIFICATE_EXPIRATION] > 168h"],
            },
        ]

        def guess_scheme(port_name, port_number):
            name = (port_name or "").lower()
            if "https" in name or port_number == 443:
                return "https"
            if "http" in name or port_number == 80:
                return "http"
            if "tcp" in name:
                return "tcp"
            if "icmp" in name:
                return "icmp"
            return "tcp"

        def list_workloads(namespaces: Iterable[str]) -> Dict[str, List[dict]]:
            workloads: Dict[str, List[dict]] = {}
            for path in ["/apis/apps/v1/deployments", "/apis/apps/v1/statefulsets"]:
                data = kube_get(path, ctx)
                for item in data.get("items", []):
                    ns = item.get("metadata", {}).get("namespace")
                    if ns not in namespaces:
                        continue
                    tmpl = item.get("spec", {}).get("template", {}) or {}
                    labels = tmpl.get("metadata", {}).get("labels", {}) or {}
                    pod_spec = tmpl.get("spec", {}) or {}
                    containers = pod_spec.get("containers", []) or []
                    port_map = {}
                    probes = []
                    for c in containers:
                        for p in c.get("ports", []) or []:
                            if p.get("name"):
                                port_map[p["name"]] = p.get("containerPort")
                        for probe in [c.get("readinessProbe"), c.get("livenessProbe")]:
                            if probe:
                                probes.append(probe)
                    workloads.setdefault(ns, []).append(
                        {"labels": labels, "port_map": port_map, "probes": probes}
                    )
            return workloads

        def match_probe(service_selector, workload: dict):
            if not service_selector:
                return None
            wl_labels = workload.get("labels", {})
            for key, val in service_selector.items():
                if wl_labels.get(key) != val:
                    return None
            for probe in workload.get("probes", []):
                if "httpGet" in probe:
                    http = probe["httpGet"]
                    port = http.get("port")
                    if isinstance(port, str):
                        port = workload["port_map"].get(port)
                    return {
                        "scheme": http.get("scheme", "HTTP").lower(),
                        "path": http.get("path", "/"),
                        "port": port,
                        "periodSeconds": probe.get("periodSeconds"),
                    }
                if "tcpSocket" in probe:
                    tcp = probe["tcpSocket"]
                    port = tcp.get("port")
                    if isinstance(port, str):
                        port = workload["port_map"].get(port)
                    return {"scheme": "tcp", "port": port, "periodSeconds": probe.get("periodSeconds")}
            return None

        def resolve_port(ports: list, probe_port):
            if probe_port:
                return probe_port
            if not ports:
                return None
            return ports[0].get("port")

        from urllib.parse import quote
        encoded = quote(selector, safe="=,")
        svc_data = kube_get(f"/api/v1/services?labelSelector={encoded}", ctx)
        services = svc_data.get("items", []) if svc_data else []

        namespaces = {item.get("metadata", {}).get("namespace") for item in services}
        workloads = list_workloads(namespaces)

        discovered = []
        for item in services:
            meta = item.get("metadata", {})
            spec = item.get("spec", {})
            name = meta.get("name")
            namespace = meta.get("namespace")
            labels = meta.get("labels", {})
            if labels.get("gatus.edgard.org/enabled") != "true":
                continue
            if labels.get("homelab.edgard.org/managed") == "gatus":
                continue
            svc_selector = spec.get("selector") or {}

            ports = spec.get("ports", []) or []
            if not ports:
                continue
            port_entry = ports[0]
            port_number = port_entry.get("port")
            port_name = port_entry.get("name")
            scheme = guess_scheme(port_name, port_number)
            path = "/"

            probe = None
            for wl in workloads.get(namespace, []):
                probe = match_probe(svc_selector, wl)
                if probe:
                    break

            if probe:
                scheme = probe.get("scheme", scheme)
                port_number = resolve_port(ports, probe.get("port"))
                path = probe.get("path", "/")
                period = probe.get("periodSeconds")
            else:
                period = None
                port_number = resolve_port(ports, port_number)

            if port_number is None:
                continue

            if scheme == "tcp":
                url = f"tcp://{name}.{namespace}.svc.cluster.local:{port_number}"
                conditions = ["[CONNECTED] == true"]
            elif scheme == "icmp":
                url = f"icmp://{name}.{namespace}.svc.cluster.local"
                conditions = ["[CONNECTED] == true"]
            else:
                url = f"{scheme}://{name}.{namespace}.svc.cluster.local:{port_number}{path}"
                conditions = ["[STATUS] == 200"]

            discovered.append(
                {
                    "name": name,
                    "group": namespace,
                    "url": url,
                    "labels": {
                        "namespace": namespace,
                        "scope": "internal",
                    },
                    "interval": f"{period}s" if period else "1m",
                    "conditions": conditions,
                }
            )
        return static_endpoints + discovered, {
            "endpointCount": len(discovered) + len(static_endpoints),
            "discoveredCount": len(discovered),
            "appCount": len(discovered) + len(static_endpoints),
        }

    def patch_config(config: dict, data: list):
        config['endpoints'] = data

    def render_config(base_config: dict, selector: str, logger, *, ctx: ClusterContext | None = None, trace: str | None = None):
        if not base_config:
            raise SystemExit("base config is required")
        if ctx is None:
            ctx = cluster_context()

        data_list, stats = discover(selector, logger, ctx)

        cfg = copy.deepcopy(base_config)
        patch_config(cfg, data_list)

        logger.debug(
            "rendered config trace=%s endpoints=%s discovered=%s selector=%s",
            trace or "-",
            stats.get("endpointCount"),
            stats.get("discoveredCount"),
            selector,
        )
        return cfg, stats

    def main():  # pragma: no cover - manual execution helper
        logger = setup_logging()
        ctx = cluster_context()

        base_path = Path(os.environ.get("CONFIG_TEMPLATE", "/scripts/base.yaml.j2"))
        out_path = Path(os.environ.get("CONFIG_OUT", "/config/config.yaml"))

        # Assume base file is valid YAML now (after migration)
        try:
            base_config = yaml.safe_load(base_path.read_text(encoding="utf-8"))
        except Exception:
            base_config = {}

        cfg, stats = render_config(base_config=base_config, selector=DEFAULT_SELECTOR, logger=logger, ctx=ctx, trace="standalone")

        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(yaml.safe_dump(cfg, sort_keys=False), encoding="utf-8")
        logger.debug(
            "generated config apps=%s endpoints=%s discovered=%s selector=%s path=%s",
            stats.get("appCount"),
            stats.get("endpointCount"),
            stats.get("discoveredCount"),
            DEFAULT_SELECTOR,
            str(out_path),
        )

    if __name__ == "__main__":
        main()
  webhook.py: |-
    import hashlib
    import json
    import logging
    import os
    from datetime import datetime, timezone
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from pathlib import Path

    import yaml

    import generator

    LOG_LEVEL = os.environ.get("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, LOG_LEVEL, logging.INFO),
        format="%(asctime)s %(levelname)s %(name)s %(message)s",
    )

    DEFAULT_SELECTOR = os.environ.get("DISCOVERY_SELECTOR", generator.DEFAULT_SELECTOR)
    DEFAULT_RESYNC = int(os.environ.get("RESYNC_SECONDS", "120"))
    DEFAULT_OUTPUT_KEY = os.environ.get("OUTPUT_KEY", "config.yaml")
    SERVER_PORT = int(os.environ.get("WEBHOOK_PORT", "8080"))

    def get_current_namespace():
        try:
            return Path("/var/run/secrets/kubernetes.io/serviceaccount/namespace").read_text().strip()
        except Exception:
            return "default"

    def build_response(parent: dict, logger):
        metadata = parent.get("metadata") or {}
        spec = parent.get("spec") or {}
        parent_status = parent.get("status") or {}

        # Derive managed resource from Kind (e.g. DexConfig -> dex)
        kind = parent.get("kind", "")
        managed_resource = kind.replace("Config", "").lower() or "unknown"
        default_output_cm = f"{managed_resource}-config-generated"

        namespace = metadata.get("namespace") or get_current_namespace()
        output_name = spec.get("outputConfigMap") or default_output_cm
        output_key = spec.get("outputKey") or DEFAULT_OUTPUT_KEY
        selector = spec.get("discoverySelector") or DEFAULT_SELECTOR
        resync = int(spec.get("resyncSeconds") or DEFAULT_RESYNC)

        base_config = spec.get("base", {})

        # Use generator.cluster_context() directly if available, or generic one
        ctx = generator.cluster_context()

        config, stats = generator.render_config(
            base_config=base_config,
            selector=selector,
            logger=logger,
            ctx=ctx,
            trace=f"{namespace}/{metadata.get('name', '')}",
        )

        cfg_yaml = yaml.safe_dump(config, sort_keys=False)
        cfg_hash = hashlib.sha256(cfg_yaml.encode("utf-8")).hexdigest()

        endpoints = stats.get("endpointCount", 0)
        discovered = stats.get("discoveredCount", endpoints)
        app_count = stats.get("appCount", endpoints)

        prev_hash = parent_status.get("configHash")

        if prev_hash == cfg_hash:
            status = parent_status
        else:
            now = datetime.now(timezone.utc).isoformat()
            status = {
                "lastSync": now,
                "appCount": app_count,
                "endpointCount": endpoints,
                "discovered": discovered,
                "configHash": cfg_hash,
                "conditions": [
                    {
                        "type": "Ready",
                        "status": "True",
                        "reason": "SyncSuccessful",
                        "message": f"Rendered {endpoints} endpoints ({discovered} discovered)",
                        "lastTransitionTime": now,
                    }
                ],
            }

        logger.info(
            "sync successful parent=%s/%s cm=%s selector=%s endpoints=%s discovered=%s",
            namespace,
            metadata.get("name"),
            output_name,
            selector,
            endpoints,
            discovered,
        )

        return {
            "children": [
                {
                    "apiVersion": "v1",
                    "kind": "ConfigMap",
                    "metadata": {
                        "name": output_name,
                        "namespace": namespace,
                        "labels": {
                            "app.kubernetes.io/name": managed_resource,
                            "app.kubernetes.io/part-of": managed_resource,
                            "homelab.edgard.org/managed": managed_resource,
                        },
                    },
                    "data": {output_key: cfg_yaml},
                }
            ],
            "status": status,
            "resyncAfterSeconds": resync,
        }

    class Handler(BaseHTTPRequestHandler):
        def do_POST(self):  # noqa: N802 - metacontroller expects POST
            if self.path != "/sync":
                self.send_error(404, "not found")
                return

            length = int(self.headers.get("Content-Length", "0"))
            raw_body = self.rfile.read(length) if length else b"{}"
            try:
                body = json.loads(raw_body or b"{}")
            except json.JSONDecodeError as exc:
                self._write_json(400, {"error": f"invalid json: {exc}"})
                return

            parent = body.get("parent") or {}
            spec = parent.get("spec") or {}
            resync = int(spec.get("resyncSeconds") or DEFAULT_RESYNC)
            logger = logging.getLogger("webhook")

            try:
                response = build_response(parent, logger)
                self._write_json(200, response)
            except Exception as exc:  # pragma: no cover - surfaced via status
                now = datetime.now(timezone.utc).isoformat()
                logging.exception("sync error")
                # Use DEFAULT_RESYNC as fallback if parsing failed
                resync = DEFAULT_RESYNC
                self._write_json(
                    200,
                    {
                        "status": {
                            "lastSync": now,
                            "appCount": 0,
                            "endpointCount": 0,
                            "discovered": 0,
                            "configHash": None,
                            "conditions": [
                                {
                                    "type": "Ready",
                                    "status": "False",
                                    "reason": "SyncError",
                                    "message": str(exc),
                                    "lastTransitionTime": now,
                                }
                            ],
                        },
                        "resyncAfterSeconds": resync,
                    },
                )

        def log_message(self, fmt, *args):  # pragma: no cover - quiet logs
            return

        def _write_json(self, code, payload):
            data = json.dumps(payload).encode("utf-8")
            self.send_response(code)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(data)))
            self.end_headers()
            self.wfile.write(data)

        def do_GET(self):
            if self.path in ("/healthz", "/livez", "/readyz"):
                self._write_json(200, {"status": "ok"})
            else:
                self.send_error(404, "not found")

    if __name__ == "__main__":
        server = HTTPServer(("", SERVER_PORT), Handler)
        logging.getLogger("webhook").info(
            "starting metacontroller webhook on :%s",
            SERVER_PORT,
        )
        server.serve_forever()
