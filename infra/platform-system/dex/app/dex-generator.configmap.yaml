---
apiVersion: v1
kind: ConfigMap
metadata:
  name: dex-generator
  namespace: platform-system
data:
  base.yaml: |-
    issuer: https://id.edgard.org
    storage:
      type: sqlite3
      config:
        file: /data/dex.db
    web:
      http: 0.0.0.0:5556
    telemetry:
      http: 0.0.0.0:5558
    logger:
      level: info
    frontend:
      issuer: Homelab Identity
    oauth2:
      skipApprovalScreen: true
    enablePasswordDB: true
    staticPasswords:
      - email: castro@edgard.org
        username: edgard
        hashFromEnv: DEX_STATIC_PASSWORD_ADMIN_HASH
    staticClients:
      - id: envoy-gateway
        name: Envoy Gateway
        redirectURIs: []
        secretEnv: ENVOY_GATEWAY_CLIENT_SECRET
  generator.py: |-
    import os
    import ssl
    import sys
    import urllib.error
    import urllib.parse
    import urllib.request
    from pathlib import Path

    import yaml

    def fetch_json(host, port, token, ctx, path, ignore_errors=(404, 403)):
        url = f"https://{host}:{port}{path}"
        req = urllib.request.Request(
            url,
            headers={
                "Authorization": f"Bearer {token}",
                "Accept": "application/json",
            },
        )
        try:
            with urllib.request.urlopen(req, context=ctx) as resp:
                return yaml.safe_load(resp.read())
        except urllib.error.HTTPError as err:
            if err.code in ignore_errors:
                print(f"warn: {path} -> HTTP {err.code}")
                return None
            raise

    def list_security_policies(host, port, token, ctx, namespace=None):
        ns = f"/namespaces/{namespace}" if namespace else ""
        return fetch_json(
            host,
            port,
            token,
            ctx,
            f"/apis/gateway.envoyproxy.io/v1alpha1{ns}/securitypolicies",
        ) or {}

    def get_routes_from_policies(policies, expected_client, expected_issuer):
        targets = set()
        for item in policies.get("items", []):
            spec = item.get("spec", {}) or {}
            oidc = spec.get("oidc", {}) or {}
            provider = oidc.get("provider", {}) or {}
            client_id = oidc.get("clientID")
            issuer = provider.get("issuer")
            if client_id != expected_client:
                continue
            if issuer and expected_issuer and issuer != expected_issuer:
                continue
            policy_ns = (item.get("metadata", {}) or {}).get("namespace")
            for tref in spec.get("targetRefs", []) or []:
                if tref.get("group") == "gateway.networking.k8s.io" and tref.get("kind") == "HTTPRoute":
                    ns = tref.get("namespace") or policy_ns
                    name = tref.get("name")
                    if ns and name:
                        targets.add((ns, name))
        return targets

    def fetch_route(host, port, token, ctx, namespace, name):
        if not namespace or not name:
            return None
        return fetch_json(
            host,
            port,
            token,
            ctx,
            f"/apis/gateway.networking.k8s.io/v1/namespaces/{namespace}/httproutes/{name}",
        )

    def collect_hosts(host, port, token, ctx, targets):
        hostnames = set()
        for ns, name in targets:
            route = fetch_route(host, port, token, ctx, ns, name)
            if not route:
                continue
            for h in route.get("spec", {}).get("hostnames", []) or []:
                hostnames.add(h.lower())
        return sorted(hostnames)

    def build_config(base, hosts):
        redirects = [f"https://{h}/oauth2/callback" for h in hosts]
        clients = base.get("staticClients", [])
        if not clients:
            raise SystemExit("base config missing staticClients")
        clients[0]["redirectURIs"] = redirects
        return base

    def main():
        host = os.environ.get("KUBERNETES_SERVICE_HOST")
        port = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
        token_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/token")
        ca_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
        base_path = Path(os.environ.get("CONFIG_TEMPLATE", "/generator/base.yaml"))
        out_path = Path(os.environ.get("CONFIG_OUT", "/etc/dex/config.yaml"))

        if not host:
            sys.exit("missing KUBERNETES_SERVICE_HOST")

        token = token_path.read_text(encoding="utf-8").strip()

        ctx = ssl.create_default_context(cafile=ca_path)
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

        base = yaml.safe_load(base_path.read_text(encoding="utf-8")) or {}
        expected_client = base.get("staticClients", [{}])[0].get("id")
        expected_issuer = base.get("issuer")

        policies = list_security_policies(host, port, token, ctx)
        targets = get_routes_from_policies(policies, expected_client, expected_issuer)
        hosts = collect_hosts(host, port, token, ctx, targets)

        final_cfg = build_config(base, hosts)
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(yaml.safe_dump(final_cfg, sort_keys=False), encoding="utf-8")

    if __name__ == "__main__":
        main()
