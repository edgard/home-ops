---
apiVersion: v1
kind: ConfigMap
metadata:
  name: hajimari-config-sync-scripts
  namespace: edge-services
data:
  generator.py: |-
    import json
    import os
    import ssl
    import sys
    import logging
    import urllib.error
    import urllib.parse
    import urllib.request
    from dataclasses import dataclass
    from pathlib import Path
    from typing import Iterable, Optional

    try:
        import yaml
    except ImportError:  # pragma: no cover - handled in container entrypoint
        sys.exit("PyYAML is required")

    def setup_logging():
        level = os.environ.get("LOG_LEVEL", "INFO").upper()
        logging.basicConfig(
            level=getattr(logging, level, logging.INFO),
            format="%(asctime)s %(levelname)s %(name)s %(message)s",
        )
        return logging.getLogger("hajimari-generator")

    DEFAULT_ROUTE_SELECTOR = "hajimari.edgard.org/enabled=true,external-dns.edgard.org/scope=external"
    DEFAULT_ICON = "mdi:web"

    @dataclass
    class Entry:
        host: str
        namespace: str
        routename: str
        icon: Optional[str]

    def display_name(hostname: str) -> str:
        clean = hostname.replace(".edgard.org", "")
        if clean in ("www", "edgard.org"):
            return "Website"
        left = clean.split(".")[0]
        return left.replace("-", " ").title()

    def display_icon(icon_override: Optional[str]) -> str:
        return f"mdi:{icon_override}" if icon_override else DEFAULT_ICON

    def fetch_json(host, port, token, ctx, path, ignore_404=True):
        url = f"https://{host}:{port}{path}"
        req = urllib.request.Request(
            url,
            headers={
                "Authorization": f"Bearer {token}",
                "Accept": "application/json",
            },
        )
        try:
            with urllib.request.urlopen(req, context=ctx) as resp:
                return json.loads(resp.read())
        except urllib.error.HTTPError as err:
            if ignore_404 and err.code == 404:
                return None
            raise

    def load_routes(host, port, token, ctx, selector: str):
        quoted = urllib.parse.quote(selector, safe="=,")
        data = fetch_json(
            host,
            port,
            token,
            ctx,
            f"/apis/gateway.networking.k8s.io/v1/httproutes?labelSelector={quoted}",
        )
        if not data:
            return []

        entries = []
        for item in data.get("items", []):
            meta = item.get("metadata", {}) or {}
            labels = meta.get("labels", {}) or {}
            if labels.get("metacontroller.edgard.org/managed") == "hajimari":
                continue
            if labels.get("hajimari.edgard.org/enabled") != "true":
                continue
            ns = meta.get("namespace")
            name = meta.get("name")
            icon = labels.get("hajimari.edgard.org/icon")
            for host in item.get("spec", {}).get("hostnames", []) or []:
                entries.append(Entry(host=host, namespace=ns, routename=name, icon=icon))
        return entries

    def build_config(entries: Iterable[Entry], base: dict) -> dict:
        groups = {}
        seen_hosts = set()
        seen_names = set()
        for entry in entries:
            key = entry.host.lower()
            if key in seen_hosts:
                continue
            name = display_name(entry.host)
            if name in seen_names:
                continue
            seen_hosts.add(key)
            seen_names.add(name)
            grp = groups.setdefault(entry.namespace, {"apps": []})
            grp["apps"].append(
                {
                    "name": name,
                    "url": f"https://{entry.host}",
                    "icon": display_icon(entry.icon),
                    "info": f"{entry.namespace}/{entry.routename}",
                    "targetBlank": False,
                }
            )

        for grp in groups.values():
            grp["apps"].sort(key=lambda x: x["name"].lower())

        custom_apps = [
            {"group": ns.replace("-", " ").title(), "apps": grp["apps"]}
            for ns, grp in sorted(groups.items(), key=lambda x: x[0])
        ]

        base["customApps"] = custom_apps
        return base

    def render_config(base_path: Path, selector: str, host: str, port: str, token: str, ctx, logger, static_apps_path: Path, static_bookmarks_path: Path):
        base = yaml.safe_load(base_path.read_text(encoding="utf-8")) or {}
        entries = load_routes(host, port, token, ctx, selector)
        cfg = build_config(entries, base)
        discovered_apps = cfg.get("customApps", []) or []
        static_apps = yaml.safe_load(static_apps_path.read_text(encoding="utf-8")) if static_apps_path.exists() else []
        if static_apps and not isinstance(static_apps, list):
            raise SystemExit(f"static apps must be a list, got {type(static_apps)}")

        static_bookmarks_raw = yaml.safe_load(static_bookmarks_path.read_text(encoding="utf-8")) if static_bookmarks_path.exists() else []
        if static_bookmarks_raw and not isinstance(static_bookmarks_raw, list):
            raise SystemExit(f"static bookmarks must be a list, got {type(static_bookmarks_raw)}")

        cfg["customApps"] = discovered_apps + static_apps

        bookmark_groups = []
        for group in static_bookmarks_raw or []:
            if not isinstance(group, dict) or "bookmarks" not in group or "group" not in group:
                raise SystemExit("static bookmarks must be a list of {group, bookmarks}")
            if not isinstance(group["bookmarks"], list):
                raise SystemExit("static bookmarks 'bookmarks' must be a list")
            bookmark_groups.append({"group": group["group"], "bookmarks": group["bookmarks"]})

        if bookmark_groups:
            cfg["globalBookmarks"] = bookmark_groups

        discovered_count = sum(len(g.get("apps", [])) for g in discovered_apps)
        static_count = sum(len(g.get("apps", [])) for g in static_apps) if static_apps else 0
        bookmark_count = sum(len(g.get("bookmarks", [])) for g in bookmark_groups) if bookmark_groups else 0
        app_count = discovered_count + static_count
        stats = {
            "appCount": app_count,
            "endpointCount": app_count,
            "discoveredCount": discovered_count,
            "staticCount": static_count,
            "bookmarkCount": bookmark_count,
        }
        logger.debug(
            "rendered hajimari config apps=%s discovered=%s static=%s bookmarks=%s selector=%s",
            app_count,
            discovered_count,
            static_count,
            bookmark_count,
            selector,
        )
        return cfg, stats

    def write_config(config: dict, out_path: Path):
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(yaml.safe_dump(config, sort_keys=False), encoding="utf-8")

    def main():
        logger = setup_logging()

        host = os.environ.get("KUBERNETES_SERVICE_HOST")
        port = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
        out_path = Path(os.environ.get("CONFIG_OUT", "/config/config.yaml"))
        base_path = Path(os.environ.get("CONFIG_TEMPLATE", "/templates/base.yaml"))
        selector = os.environ.get("ROUTE_SELECTOR", DEFAULT_ROUTE_SELECTOR)
        token_path = Path("/var/run/secrets/kubernetes.io/serviceaccount/token")
        ca_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
        static_apps_path = Path(os.environ.get("CONFIG_STATIC", "/templates/static-apps.yaml"))
        static_bookmarks_path = Path(os.environ.get("CONFIG_BOOKMARKS", "/templates/static-bookmarks.yaml"))

        if not host:
            sys.exit("missing KUBERNETES_SERVICE_HOST")

        token = token_path.read_text(encoding="utf-8").strip()

        ctx = ssl.create_default_context(cafile=ca_path)
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

        final_cfg, stats = render_config(base_path, selector, host, port, token, ctx, logger, static_apps_path, static_bookmarks_path)

        write_config(final_cfg, out_path)
        logger.debug(
            "generated hajimari config apps=%s endpoints=%s discovered=%s static=%s bookmarks=%s selector=%s path=%s",
            stats.get("appCount"),
            stats.get("endpointCount"),
            stats.get("discoveredCount"),
            stats.get("staticCount"),
            stats.get("bookmarkCount"),
            selector,
            str(out_path),
        )

    if __name__ == "__main__":
        main()
  webhook.py: |-
    import json
    import os
    import ssl
    import logging
    from datetime import datetime, timezone
    import hashlib
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from pathlib import Path

    import yaml

    import generator

    LOG_LEVEL = os.environ.get("LOG_LEVEL", "INFO").upper()
    logging.basicConfig(
        level=getattr(logging, LOG_LEVEL, logging.INFO),
        format="%(asctime)s %(levelname)s %(name)s %(message)s",
    )

    TOKEN_PATH = Path("/var/run/secrets/kubernetes.io/serviceaccount/token")
    CA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    BASE_PATH = Path(os.environ.get("CONFIG_TEMPLATE", "/templates/base.yaml"))
    STATIC_PATH = Path(os.environ.get("CONFIG_STATIC", "/templates/static-apps.yaml"))
    STATIC_BOOKMARKS_PATH = Path(os.environ.get("CONFIG_BOOKMARKS", "/templates/static-bookmarks.yaml"))
    DEFAULT_SELECTOR = os.environ.get("ROUTE_SELECTOR", generator.DEFAULT_ROUTE_SELECTOR)
    DEFAULT_RESYNC = int(os.environ.get("RESYNC_SECONDS", "120"))
    DEFAULT_OUTPUT_CM = os.environ.get("OUTPUT_CONFIGMAP", "hajimari-config-generated")
    DEFAULT_OUTPUT_KEY = os.environ.get("OUTPUT_KEY", "config.yaml")
    SERVER_PORT = int(os.environ.get("WEBHOOK_PORT", "8080"))

    def build_response(namespace: str, output_name: str, output_key: str, selector: str, resync: int, parent_meta: dict, parent_status: dict, logger):
        host = os.environ.get("KUBERNETES_SERVICE_HOST")
        port = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
        if not host:
            raise SystemExit("missing KUBERNETES_SERVICE_HOST")

        token = TOKEN_PATH.read_text(encoding="utf-8").strip()
        ctx = ssl.create_default_context(cafile=CA_PATH)
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE

        config, stats = generator.render_config(BASE_PATH, selector, host, port, token, ctx, logger, STATIC_PATH, STATIC_BOOKMARKS_PATH)
        cfg_yaml = yaml.safe_dump(config, sort_keys=False)
        cfg_hash = hashlib.sha256(cfg_yaml.encode("utf-8")).hexdigest()

        apps = stats.get("appCount", 0)

        prev_status = parent_status or {}
        prev_hash = prev_status.get("configHash")

        if prev_hash == cfg_hash:
            status = prev_status
        else:
            now = datetime.now(timezone.utc).isoformat()
            status = {
                "lastSync": now,
                "configHash": cfg_hash,
                "appCount": apps,
                "endpointCount": stats.get("endpointCount", apps),
                "discovered": stats.get("discoveredCount", 0),
                "static": stats.get("staticCount", 0),
                "conditions": [
                    {
                        "type": "Ready",
                        "status": "True",
                        "reason": "SyncSuccessful",
                        "message": (
                            f"Rendered {apps} endpoints "
                            f"({stats.get('discoveredCount', 0)} discovered, "
                            f"{stats.get('staticCount', 0)} static, "
                            f"{stats.get('bookmarkCount', 0)} bookmarks)"
                        ),
                        "lastTransitionTime": now,
                    }
                ],
            }

        logger.info(
            "sync successful ns=%s cm=%s apps=%s bookmarks=%s endpoints=%s discovered=%s static=%s selector=%s",
            namespace,
            output_name,
            apps,
            stats.get("bookmarkCount", 0),
            stats.get("endpointCount", apps),
            stats.get("discoveredCount", 0),
            stats.get("staticCount", 0),
            selector,
        )
        payload = {
            "children": [
                {
                    "apiVersion": "v1",
                    "kind": "ConfigMap",
                    "metadata": {
                        "name": output_name,
                        "namespace": namespace,
                        "labels": {
                            "app.kubernetes.io/name": "hajimari",
                            "app.kubernetes.io/part-of": "hajimari",
                            "metacontroller.edgard.org/managed": "hajimari",
                        },
                    },
                    "data": {
                        output_key: cfg_yaml,
                    },
                }
            ],
            "status": status,
            "resyncAfterSeconds": resync,
        }
        return payload

    class Handler(BaseHTTPRequestHandler):
        def do_POST(self):  # noqa: N802 - metacontroller expects POST
            if self.path != "/sync":
                self.send_error(404, "not found")
                return

            length = int(self.headers.get("Content-Length", "0"))
            raw_body = self.rfile.read(length) if length else b"{}"
            body = json.loads(raw_body or "{}")
            parent = body.get("parent") or {}
            metadata = parent.get("metadata") or {}
            status = parent.get("status") or {}
            spec = parent.get("spec") or {}

            namespace = metadata.get("namespace") or "edge-services"
            output_name = spec.get("outputConfigMap") or DEFAULT_OUTPUT_CM
            output_key = spec.get("outputKey") or DEFAULT_OUTPUT_KEY
            selector = spec.get("routeSelector") or DEFAULT_SELECTOR
            resync = int(spec.get("resyncSeconds") or DEFAULT_RESYNC)

            try:
                response = build_response(namespace, output_name, output_key, selector, resync, parent.get("metadata") or {}, status, logging.getLogger("hajimari-webhook"))
                self._write_json(200, response)
            except Exception as exc:  # pragma: no cover - surfaced via status
                now = datetime.now(timezone.utc).isoformat()
                logging.exception("sync error")
                self._write_json(
                    200,
                    {
                        "status": {
                            "lastSync": now,
                            "appCount": 0,
                            "endpointCount": 0,
                            "discovered": 0,
                            "static": 0,
                            "conditions": [
                                {
                                    "type": "Ready",
                                    "status": "False",
                                    "reason": "SyncError",
                                    "message": str(exc),
                                    "lastTransitionTime": now,
                                }
                            ],
                        },
                        "resyncAfterSeconds": resync,
                    },
                )

        def log_message(self, fmt, *args):  # pragma: no cover - quiet logs
            return

        def _write_json(self, code, payload):
            data = json.dumps(payload).encode("utf-8")
            self.send_response(code)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(data)))
            self.end_headers()
            self.wfile.write(data)

    if __name__ == "__main__":
        server = HTTPServer(("", SERVER_PORT), Handler)
        server.serve_forever()
