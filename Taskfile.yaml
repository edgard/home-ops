---
version: "3"

silent: true
failfast: true
set:
  - errexit
  - nounset
  - pipefail
shell: bash -c

vars:
  TERRAFORM_DIR: '{{.TERRAFORM_DIR | default (printf "%s/terraform" .TASKFILE_DIR)}}'
  CLUSTER_NAME: '{{.CLUSTER_NAME | default "homelab"}}'
  K3S_VERSION: '{{.K3S_VERSION | default "v1.33.6-k3s1"}}'

tasks:
  default:
    desc: List available tasks
    cmds:
      - task --list

  bootstrap:create:
    desc: Bootstrap k3d cluster and deploy platform via helmfile
    dir: "{{.TASKFILE_DIR}}/bootstrap"
    requires:
      vars:
        - DOCKER_HOST
        - BWS_ACCESS_TOKEN
    env:
      DOCKER_HOST: "{{.DOCKER_HOST}}"
      BWS_ACCESS_TOKEN: "{{.BWS_ACCESS_TOKEN}}"
      CLUSTER_NAME: "{{.CLUSTER_NAME}}"
      K3S_VERSION: "{{.K3S_VERSION}}"
    cmds:
      - ./bootstrap-k3d.sh create

  bootstrap:destroy:
    desc: Destroy k3d cluster
    interactive: true
    dir: "{{.TASKFILE_DIR}}/bootstrap"
    requires:
      vars:
        - DOCKER_HOST
    env:
      DOCKER_HOST: "{{.DOCKER_HOST}}"
      CLUSTER_NAME: "{{.CLUSTER_NAME}}"
    cmds:
      - ./bootstrap-k3d.sh destroy

  bootstrap:recreate:
    desc: Destroy and recreate k3d cluster
    interactive: true
    dir: "{{.TASKFILE_DIR}}/bootstrap"
    requires:
      vars:
        - DOCKER_HOST
        - BWS_ACCESS_TOKEN
    env:
      DOCKER_HOST: "{{.DOCKER_HOST}}"
      BWS_ACCESS_TOKEN: "{{.BWS_ACCESS_TOKEN}}"
      CLUSTER_NAME: "{{.CLUSTER_NAME}}"
      K3S_VERSION: "{{.K3S_VERSION}}"
    cmds:
      - ./bootstrap-k3d.sh recreate

  lint:
    desc: Format + lint all code (YAML, Terraform, Helm)
    dir: "{{.TASKFILE_DIR}}"
    requires:
      vars:
        - AWS_ACCESS_KEY_ID
        - AWS_SECRET_ACCESS_KEY
        - CLOUDFLARE_API_TOKEN
        - TF_VAR_cloudflare_zone_id
    cmds:
      - task: lint:yaml
      - task: lint:terraform
      - task: lint:helm

  lint:yaml:
    desc: Format and lint YAML files
    dir: "{{.TASKFILE_DIR}}"
    cmds:
      - 'prettier --write "**/*.{yaml,yml}"'
      - 'yamlfmt "**/*.{yaml,yml}"'
      - "yamllint ."

  lint:terraform:
    desc: Format and validate Terraform configs
    dir: "{{.TERRAFORM_DIR}}"
    requires:
      vars:
        - AWS_ACCESS_KEY_ID
        - AWS_SECRET_ACCESS_KEY
        - CLOUDFLARE_API_TOKEN
        - TF_VAR_cloudflare_zone_id
    cmds:
      - "tofu fmt -recursive"
      - "tofu init -backend=false"
      - "tofu validate"

  lint:helm:
    desc: Validate all Helm charts (app-template and custom charts)
    dir: "{{.TASKFILE_DIR}}"
    cmds:
      - |
        failed=0
        for config in apps/*/*/config.yaml; do
          if [ -f "$config" ]; then
            app=$(basename $(dirname "$config"))
            values="${config%config.yaml}values.yaml"

            if [ ! -f "$values" ]; then
              continue
            fi

            # Extract chart info from config.yaml
            repo=$(yq eval '.chart.repo' "$config")
            version=$(yq eval '.chart.version' "$config")

            if [ "$repo" = "null" ]; then
              echo "⚠️  Skipped $app: No chart repo defined"
              continue
            fi

            # Handle OCI vs HTTP repos
            if [[ "$repo" == oci://* ]]; then
              # For OCI repos, the full path is in repo
              chart="$repo"
            else
              # For HTTP repos, we need the name field
              name=$(yq eval '.chart.name' "$config")
              if [ "$name" = "null" ]; then
                echo "⚠️  Skipped $app: Missing chart name"
                continue
              fi

              # Add HTTP repo with unique name based on URL hash
              repo_name=$(echo "$repo" | md5sum | cut -d' ' -f1)
              helm repo add "$repo_name" "$repo" >/dev/null 2>&1 || true
              helm repo update "$repo_name" >/dev/null 2>&1 || true
              chart="$repo_name/$name"
            fi

            chart_display=$(basename "$repo")
            if ! helm template test "$chart" --version "$version" --values "$values" >/dev/null 2>&1; then
              echo "❌ Failed $app: $chart_display $version"
              failed=1
            else
              echo "✓ Valid $app: $chart_display $version"
            fi
          fi
        done

        if [ $failed -eq 1 ]; then
          exit 1
        fi

  argo:sync:
    desc: Force Argo CD Applications to refresh
    vars:
      app: '{{.app | default ""}}'
    cmds:
      - 'kubectl -n argocd get applications {{if .app}}-l "app={{.app}}"{{end}} -o name | xargs -r -n1 -I{} kubectl -n argocd patch {} --type merge -p ''{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'' >/dev/null || true'

  tf:plan:
    desc: Terraform plan
    dir: "{{.TERRAFORM_DIR}}"
    requires:
      vars:
        - AWS_ACCESS_KEY_ID
        - AWS_SECRET_ACCESS_KEY
        - CLOUDFLARE_API_TOKEN
        - TF_VAR_cloudflare_zone_id
    cmds:
      - "tofu init"
      - "tofu plan"

  tf:apply:
    desc: Terraform apply
    dir: "{{.TERRAFORM_DIR}}"
    requires:
      vars:
        - AWS_ACCESS_KEY_ID
        - AWS_SECRET_ACCESS_KEY
        - CLOUDFLARE_API_TOKEN
        - TF_VAR_cloudflare_zone_id
    cmds:
      - "tofu init"
      - "tofu apply"

  tf:clean:
    desc: Clean terraform state/cache
    dir: "{{.TERRAFORM_DIR}}"
    cmds:
      - rm -rf .terraform/ .terraform.lock.hcl terraform.tfstate* *.tfplan
